\input{header}

\setmathfont{Latin Modern Math}
\setmathfont{TeX Gyre Termes Math}[range=bb]
\DeclareMathAlphabet{\mathcal}{OMS}{cmsy}{m}{n}

\begin{document}

% \verb listings \tt ttfamily

% Measure size
% \begin{tikzpicture}
% \foreach \x in {-7,...,7}
% {
%   \foreach \y in {-2...,2}
%   {
%     \node (0) at (\x,\y) {\x,\y};
%   }
% }
% \end{tikzpicture}

% Hello world!
% \begin{frame}
% \frametitle{Hello world! t.miethlinger}
% \end{frame}

\includetitle{Slides/title}

\part{Introduction}
\makepart

\begin{frame}
\frametitle{About me}
\framesubtitle{(Thomas Miethlinger)}
\begin{itemize}
  \item Study: Master Physics
  \item Johannes Kepler University of Linz
  \item Institute for Theoretical Physics, Department: Many Particle Systems. \\
        Research:
        \begin{itemize}
         \item Quantum fluids
         \item Complex fluids
         \item Non-equilibrium statistical mechanics
        \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{About the GSP}

\begin{itemize}
  \item Supervisor: Dr. Edoardo Di Napoli
  \item Co-Supervisor: Dr. Xinzhe Wu
  \item SimLab Quantum Materials
  \item Research:
    \begin{itemize}
    \item Development and maintenance of numerical libraries
    \item Design and implementation of high-performance algorithms
    \item Development of new mathematical and computational models within a methodological framework
    \end{itemize}
    in the scope of computational materials science and quantum materials.
\end{itemize}
\end{frame}

\part{Introduction to HPX}
\makepart

\begin{frame}
\frametitle{Current sitution in high performance computing (HPC)}
Currently, speed-up in computing does not stem from higher CPU frequency, but increased parallelism.
However, we already face the following challenges in HPC:
\begin{itemize}
  \item Ease of programming
  \item Inability to handle dynamically changing workloads
  \item Scalability
  \item Efficient utilization of system resources
\end{itemize}
\(\implies\) a need for a new execution model: ParalleX, which is implemented by HPX
\end{frame}

\begin{frame}
\frametitle{ParalleX}
ParalleX is a new parallel execution model that offers an alternative to the conventional computation models(e.g. message passing):
\begin{itemize}
  \item Split-phase transaction model
  \item Message-driven
  \item Distributed shared memory
  \item Multi-threaded
  \item Futures synchronization
  \item Local Control Objects (LCOs)
  \item ...
\end{itemize}
ParalleX focusses on latency hiding instead of latency avoidance.
\end{frame}

\begin{frame}
\frametitle{About HPX}
\begin{itemize}
  \item High Performance ParalleX (HPX) is the first runtime system implementation of the ParalleX execution model.
  \item Development: STE||AR group \\ Louisiana State University \\ LSU Center for Computation and Technology
  \item Released as open source under the Boost Software License
  \item Current version: HPX V1.3.0, released on 23.05.2019
  \item Aims to be a \textbf{C++ standards conforming implementation} of the Parallelism and Concurrency proposals for C++ 17/20/23/...
  \item This means: HPX is a C++ library that supports \textbf{dynamic adaptive resource management} and \textbf{lightweight task programming and scheduling} within the context of a \textbf{global address space}. 
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{On learning HPX}
\framesubtitle{An opinion of a non-CS/HPC student}
Learning curve on of HPX is quite steep - in the first days quite some dedication, effort and endurance is needed\footnote{\color{fzjblue} \href{https://github.com/STEllAR-GROUP/tutorials/blob/master/hlrs2017/session1/README.md}{Why is the HPX code repo so big and complicated?}}.
\begin{itemize}
  \item Probably the easiest way in the beginning: watch
    \color{fzjblue}\href{https://www.youtube.com/playlist?list=PL1tk5lGm7zvSXfS-sqOOmIJ0lFNjKze18}{this nice playlist}
    \color{black} in 1.25x speed on the youtube channel of
    \color{fzjblue}\href{https://www.youtube.com/user/cscsch}{cscsch}
    \color{black}(Swiss National Supercomputing Centre)
  \item Be aware that the
    \color{fzjblue}\href{https://stellar-group.github.io/hpx/docs/sphinx/latest/html/api.html}{API reference}
    \color{black}is not complete
  \item Be aware that there exist at least 5 different ``Hello, World!'' examples\footnote{Paths are with respect to \color{fzjblue}\url{https://github.com/STEllAR-GROUP/}\color{black}}:
  \begin{itemize}
    \item hpx/examples/hello\_world\_component/*: 3 files; 28, 30 \& 55 lines
    \item hpx/examples/quickstart/hello\_world\_1.cpp; 22 lines
    \item hpx/examples/quickstart/hello\_world\_2.cpp; 24 lines
    \item hpx/examples/quickstart/hello\_world\_distributed.cpp; 156 lines
    \item tutorials/examples/01\_hello\_world/hello\_world.cpp; 71 lines
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{HPX: Tasks and Threads}
\begin{itemize}
 \item HPX: Task-based parallelism
 \item Split up big problem into smaller tasks
 \item Tasks are worked off as HPX (lightweight) Threads by the OS Threads
 \item Task size is crucial: not too small and not too big
 \item Number of tasks can even be as high as \(\mathcal{OABCDM}(10^8)\)
\end{itemize}
\vspace{0.3cm}
\begin{center}
\begin{tikzpicture}[
x=1cm,
y=1cm,
tasknode/.style={rectangle, draw=fzjblue!60, fill=fzjblue!5, very thick, minimum height=1cm},
]
\node at (-3cm,2cm) {Tasks too large};
\node[tasknode] at (-5cm  +0cm,0cm) [draw, thick, minimum width=2cm] {\(T_1\)};
\node[tasknode] at (-5cm  +2cm,0cm) [draw, thick, minimum width=2cm] {\(T_3\)};
\node[tasknode] at (-5cm  +4cm,0cm) [draw, thick, minimum width=2cm] {\(T_5\)};
\node[tasknode] at (-5cm+0.1cm,1cm) [draw, thick, minimum width=2.2cm] {\(T_2\)};
\node[tasknode] at (-5cm+2.2cm,1cm) [draw, thick, minimum width=2.2cm] {\(T_4\)};

\node at (3,2) {Right task size};
\node[tasknode] at (+1,0) [draw, thick, minimum width=1cm] {\(T_1\)};
\node[tasknode] at (+2,0) [draw, thick, minimum width=1cm] {\(T_3\)};
\node[tasknode] at (+3.2,1) [draw, thick, minimum width=1cm] {\(T_5\)};
\node[tasknode] at (+1.1,1) [draw, thick, minimum width=1.2cm] {\(T_2\)};
\node[tasknode] at (+2.2,1) [draw, thick, minimum width=1.2cm] {\(T_4\)};

\node[tasknode] at (3.05,0) [draw, thick, minimum width=1.1cm] {\(T_6\)};
\node[tasknode] at (4.1,0) [draw, thick, minimum width=1.1cm] {\(T_7\)};
\node[tasknode] at (5.1,0) [draw, thick, minimum width=1cm] {\(T_8\)};
\node[tasknode] at (4.3,1) [draw, thick, minimum width=1.2cm] {\(T_9\)};
% \node[tasknode] at (+2.1,1) [draw, thick, minimum width=1.05cm] {\(T_{10}\)};
% \node[tasknode] at (+2.1,1) [draw, thick, minimum width=1.05cm] {\(T_{11}\)};
\end{tikzpicture}
\end{center}
\end{frame}

\begin{frame}
\frametitle{Comparison of HPX and OpenMP}
\begin{center}
\begin{tabular}{ |c|c| } 
 \hline
 HPX & OpenMP \\
 \hline
 C++ library & Compiler extension to C and Fortran \\
 Core language: \texttt{hpx::C++} & \texttt{\#pragma omp} directives \\
 Task-based parallelism & Parallel regions (fork-join model) \\
 AGAS (active global address space) & shared memory \\
 \hline
\end{tabular}
\end{center}
\vspace{0.3cm}
\begin{center}
\begin{tikzpicture}[
initnode/.style={circle, draw=fzjgreen!60, fill=fzjgreen!5, very thick, minimum size=5mm},
masternode/.style={rectangle, draw=fzjred!60, fill=fzjred!5, very thick, minimum size=5mm},
slavenode/.style={rectangle, draw=fzjblue!60, fill=fzjblue!5, very thick, minimum size=5mm},
]
\node[initnode]      at (-5, -1) {S};
\node[slavenode]     at (-4,  1) {2};
\node[slavenode]     at (-4,  0) {1};
\node[slavenode]     at (-4, -1) {0};
\node[slavenode]     at (-3,  1) {2};
\node[slavenode]     at (-3,  0) {1};
\node[slavenode]     at (-3, -1) {0};
\node[slavenode]     at (-2,  1) {2};
\node[slavenode]     at (-2,  0) {1};
\node[slavenode]     at (-2, -1) {0};
\node[initnode]      at (-1, -1) {E};
\draw[->] (-5+0.31,  -1) -- (-4-0.27, -1);
\draw[->] (-4.5,  1) -- (-4-0.27,  1);
\draw[->] (-4.5,  0) -- (-4-0.27,  0);
\draw[->] (-4.5, -1) -- (-4-0.27, -1);
\draw[-]  (-4.5, -1) -- (-4.5, 1);
\draw[->] (-4+0.27,  1) -- (-3-0.27,  1);
\draw[->] (-4+0.27,  0) -- (-3-0.27,  0);
\draw[->] (-4+0.27, -1) -- (-3-0.27, -1);
\draw[->] (-3+0.27,  1) -- (-2-0.27,  1);
\draw[->] (-3+0.27,  0) -- (-2-0.27,  0);
\draw[->] (-3+0.27, -1) -- (-2-0.27, -1);
\draw[->] (-2+0.27,  1) -- (-1.5,  1);
\draw[->] (-2+0.27,  0) -- (-1.5,  0);
\draw[-]  (-1.5, -1) -- (-1.5, 1);
\draw[->] (-2+0.27,  -1) -- (-1-0.31, -1);

\node[initnode]      at (1, -1) {S};
\node[masternode]    at (2, -1) {0};
\node[masternode]    at (3, -1) {0};
\node[slavenode]     at (3, -0) {1};
\node[slavenode]     at (3,  1) {2};
\node[masternode]    at (4, -1) {0};
\node[initnode]      at (5, -1) {E};
\draw[->] (1+0.31, -1) -- (2-0.27, -1);
\draw[->] (2+0.27, -1) -- (3-0.27, -1);
\draw[->] (2.5,  0) -- (3-0.27,  0);
\draw[->] (2.5,  1) -- (3-0.27,  1);
\draw[-]  (2.5, -1) -- (2.5, 1);
\draw[->] (3+0.27, -1) -- (4-0.27, -1);
\draw[->] (3+0.27,  0) -- (3.5,  0);
\draw[->] (3+0.27,  1) -- (3.5,  1);
\draw[-]  (3.5, -1) -- (3.5, 1);
\draw[->] (4+0.27, -1) -- (5-0.31, -1);
\end{tikzpicture}
\end{center}
\end{frame}

\begin{frame}
\frametitle{Comparison of HPX and MPI}
\begin{center}
\begin{tabular}{ |c|c| } 
 \hline
 HPX & MPI \\
 \hline
 C++ library & Interface specification for C and Fortran \\
 Core language: \texttt{hpx::C++} & Core language: MPI\_C, MPI\_F08 \\
 Task-based parallelism & Single program, multiple data (SPMD) \\
 AGAS (active global address space) & Explicit message passing \\
 \hline
\end{tabular}
\end{center}
\vspace{0.3cm}
\begin{center}
\begin{tikzpicture}[
initnode/.style={circle, draw=fzjgreen!60, fill=fzjgreen!5, very thick, minimum size=5mm},
masternode/.style={rectangle, draw=fzjred!60, fill=fzjred!5, very thick, minimum size=5mm},
slavenode/.style={rectangle, draw=fzjblue!60, fill=fzjblue!5, very thick, minimum size=5mm},
]
\node[initnode]      at (-5, -1) {S};
\node[slavenode]     at (-4,  1) {2};
\node[slavenode]     at (-4,  0) {1};
\node[slavenode]     at (-4, -1) {0};
\node[slavenode]     at (-3,  1) {2};
\node[slavenode]     at (-3,  0) {1};
\node[slavenode]     at (-3, -1) {0};
\node[slavenode]     at (-2,  1) {2};
\node[slavenode]     at (-2,  0) {1};
\node[slavenode]     at (-2, -1) {0};
\node[initnode]      at (-1, -1) {E};
\draw[->] (-5+0.31,  -1) -- (-4-0.27, -1);
\draw[->] (-4.5,  1) -- (-4-0.27,  1);
\draw[->] (-4.5,  0) -- (-4-0.27,  0);
\draw[->] (-4.5, -1) -- (-4-0.27, -1);
\draw[-]  (-4.5, -1) -- (-4.5, 1);
\draw[->] (-4+0.27,  1) -- (-3-0.27,  1);
\draw[->] (-4+0.27,  0) -- (-3-0.27,  0);
\draw[->] (-4+0.27, -1) -- (-3-0.27, -1);
\draw[->] (-3+0.27,  1) -- (-2-0.27,  1);
\draw[->] (-3+0.27,  0) -- (-2-0.27,  0);
\draw[->] (-3+0.27, -1) -- (-2-0.27, -1);
\draw[->] (-2+0.27,  1) -- (-1.5,  1);
\draw[->] (-2+0.27,  0) -- (-1.5,  0);
\draw[-]  (-1.5, -1) -- (-1.5, 1);
\draw[->] (-2+0.27,  -1) -- (-1-0.31, -1);

\node[initnode]      at (1, -1) {S};
\node[slavenode]     at (2,  1) {2};
\node[slavenode]     at (2,  0) {1};
\node[slavenode]     at (2, -1) {0};
\node[slavenode]     at (3,  1) {2};
\node[slavenode]     at (3,  0) {1};
\node[slavenode]     at (3, -1) {0};
\node[slavenode]     at (4,  1) {2};
\node[slavenode]     at (4,  0) {1};
\node[slavenode]     at (4, -1) {0};
\node[initnode]      at (5, -1) {E};
\draw[->] (1+0.31,  -1) -- (2-0.27, -1);
\draw[->] (1.5,  1) -- (2-0.27,  1);
\draw[->] (1.5,  0) -- (2-0.27,  0);
\draw[->] (1.5, -1) -- (2-0.27, -1);
\draw[-]  (1.5, -1) -- (1.5, 1);
\draw[->] (2+0.27,  1) -- (3-0.27,  1);
\draw[->] (2+0.27,  0) -- (3-0.27,  0);
\draw[->] (2+0.27, -1) -- (3-0.27, -1);
\draw[dashed] (2+0.27,  1) -- (3-0.27,  1);
\draw[dashed] (2+0.27,  1) -- (3-0.27,  0);
\draw[dashed] (2+0.27,  1) -- (3-0.27, -1);
\draw[dashed] (2+0.27,  0) -- (3-0.27,  1);
\draw[dashed] (2+0.27,  0) -- (3-0.27,  0);
\draw[dashed] (2+0.27,  0) -- (3-0.27, -1);
\draw[dashed] (2+0.27, -1) -- (3-0.27,  1);
\draw[dashed] (2+0.27, -1) -- (3-0.27,  0);
\draw[dashed] (2+0.27, -1) -- (3-0.27, -1);
\draw[->] (3+0.27,  1) -- (4-0.27,  1);
\draw[->] (3+0.27,  0) -- (4-0.27,  0);
\draw[->] (3+0.27, -1) -- (4-0.27, -1);
\draw[dashed] (3+0.27,  1) -- (4-0.27,  1);
\draw[dashed] (3+0.27,  1) -- (4-0.27,  0);
\draw[dashed] (3+0.27,  1) -- (4-0.27, -1);
\draw[dashed] (3+0.27,  0) -- (4-0.27,  1);
\draw[dashed] (3+0.27,  0) -- (4-0.27,  0);
\draw[dashed] (3+0.27,  0) -- (4-0.27, -1);
\draw[dashed] (3+0.27, -1) -- (4-0.27,  1);
\draw[dashed] (3+0.27, -1) -- (4-0.27,  0);
\draw[dashed] (3+0.27, -1) -- (4-0.27, -1);
\draw[->] (4+0.27,  1) -- (4.5,  1);
\draw[->] (4+0.27,  0) -- (4.5,  0);
\draw[-]  (4.5, -1) -- (4.5, 1);
\draw[->] (4+0.27,  -1) -- (5-0.31, -1);
\end{tikzpicture}
\end{center}
\end{frame}

\begin{frame}
\frametitle{The HPX API}
\framesubtitle{Selection: Classes}
\begin{center}
\begin{tabular}{ |l|l| } 
 \hline
 Class & Description \\
 \hline
 \texttt{hpx::thread} & Low level thread of control \\
 \texttt{hpx::mutex} & Low level synchronization facility \\
 \texttt{hpx::lcos::local::condition\_variable} & Signal a condition \\
 \texttt{hpx::future, hpx::shared\_future} & Asynchronous result transport (receiving end) \\
 \texttt{hpx::promise, hpx::lcos::local::promise} & Asynchronous result transport (producing end) \\
 \texttt{hpx::lcos::packaged\_task} & Asynchronous result transport (producing end) \\
 \texttt{hpx::function} & Type erased function object \\
 \texttt{hpx::tuple} & Tuple \\
 \texttt{...} &  \\
 \hline
\end{tabular}
\end{center}
\end{frame}

\begin{frame}
\frametitle{The HPX API}
\framesubtitle{Selection: Functions}
\begin{center}
\begin{tabular}{ |l|l| }
 \hline
 Functions & Description \\
 \hline
 \texttt{hpx::async} & Spawning tasks (returns a future) \\
 \texttt{hpx::make\_ready\_future} & Spawning tasks (returns a ready future) \\
 \texttt{hpx::bind} & Binding Parameters to callables \\
 \texttt{hpx::apply} & Signal a condition \\
 \texttt{future::\{is\_ready, valid, has\_exception\}} & Query state of future \\
 \texttt{future::get} & Return computed result of future \\
 \texttt{future::then} & Continuations of futures \\
 \texttt{hpx::when\_all, hpx::when\_any, hpx::when\_n} & Waiting on one or more futures (non blocking) \\
 \texttt{hpx::wait\_all, hpx::wait\_any, hpx::wait\_n} & Waiting on one or more futures (blocking) \\
 \texttt{hpx::dataflow} & Shortcut to hpx::when\_all(...).then(...) \\
 \texttt{...} &  \\
 \hline
\end{tabular}
\end{center}
\end{frame}


\begin{frame}[fragile]
\frametitle{HPX: Example Program}
\begin{lstlisting}[language=C++]
double calc_area(hpx::future<double> future_r, hpx::future<double> future_pi)
{
    double r = future_r.get(); // r is returned immediately (make_ready_future)
    double pi = future_pi.get(); // pi is returned once the async computation finishes
    return r * r * pi;
}

int hpx_main(variables_map& vm) // In hpx_main the HPX environment is loaded
{
    hpx::future<double> future_r = hpx::make_ready_future(vm["r"].as<double>());
    hpx::future<double> future_pi = hpx::async([](){ return 4.0 * atan(1.0); });
    hpx::future<double> future_area = hpx::dataflow(&calc_area, future_r, future_pi);
    return hpx::finalize(); // Area can be obtained by: future_area.get()
}

int main(int argc, char * argv[]) // Start program by: ./area --r=...
{
    options_description.add_options()("r", value<double>()->default_value(1.0), "Radius: r");
    return hpx::init(options_description, argc, argv); // hpx::init calls hpx_main
}
\end{lstlisting}
\end{frame}

\part{Introduction to Numerical Linear Algebra and Applications}
\makepart

\begin{frame}
\frametitle{Introduction: Numerical Linear Algebra}
Numerical linear algebra is a subfield of numerical analysis and linear algebra,
and it plays an integral role in computational problem solving.
There exist many several algorithms for common problems, a few well-known are:
\begin{itemize}
 \item Solving systems of linear equations
 \item Eigenvalue problem
 \item Matrix inversion problem
 \item Least-squared problem
\end{itemize}
which may be using one of the following matrix operations/decompositions:
\begin{itemize}
 \item Matrix multiplications
 \item LU decomposition
 \item QR decomposition
 \item Spectral decomposition
 \item Singular value decomposition
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Applications of Numerical Linear Algebra}
\frametitle{GEMM}
GEMM - GEneral Matrix Multiply
\begin{itemize}
 \item Basic binary operation in Linear Algebra, which has numerous applications in mathematics, science and engineering.
 \item More fundamental applications of matrix multiplications include
  \begin{enumerate}
   \item Systems of Linear Algebraic Equations (SLAE) can be expressed as a single matrix equation, e.g. \(Ax = y\). 
   \item Linear map between two vector spaces \(U\) and \(V\) over the same field \(F\).
  \end{enumerate}
 \item Let the field \(F\) be \(\mathbb{R}\) or \(\mathbb{C}\), \(A =\big( a_{ij} \big) \in F^{m \times n}, B =\big( b_{jk} \big) \in F^{n \times p}\). Then,
 \begin{equation}
  C=\big( c_{ik} \big)=AB \in F^{m \times p},
 \end{equation}
 \begin{equation}
  c_{ik} = \sum_{j=1}^n{a_{ij}b_{jk}}
 \end{equation}
 \item \(\implies\) most simple implementation consists of 3 nested for-loops: \\
  \texttt{for 0 <= i < m, 0 <= j < n, 0 <= k < p, do: C[i][k] += A[i][j] * B[j][k]}
\end{itemize}
\end{frame}

\part{GEMM}
\makepart


\part{QR}
\makepart

% your talk should never end with an empty page.
% to make sure we don't see a black page, we just take the title page again
% in an ideal world, you will never "see" this frame
\includetitle{Slides/title}

\end{document}
