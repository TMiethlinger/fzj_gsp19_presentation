\input{header}

% \setmathfont{Latin Modern Math}
% \setmathfont{TeX Gyre Termes Math}[range=bb]
% \DeclareMathAlphabet{\mathcal}{OMS}{cmsy}{m}{n}

\begin{document}

% \verb listings \tt ttfamily

% Measure size
% \begin{tikzpicture}
% \foreach \x in {-7,...,7}
% {
%   \foreach \y in {-2...,2}
%   {
%     \node (0) at (\x,\y) {\x,\y};
%   }
% }
% \end{tikzpicture}

% Hello world!
% \begin{frame}
% \frametitle{Hello world! t.miethlinger}
% \end{frame}

\includetitle{Slides/title}

\part{Introduction}
\makepart

\begin{frame}
\frametitle{About me}
\framesubtitle{(Thomas Miethlinger)}
\begin{itemize}
  \item Study: Master Physics
  \item Johannes Kepler University of Linz
  \item Institute for Theoretical Physics, Department: Many Particle Systems. \\
        Research:
        \begin{itemize}
         \item Quantum fluids
         \item Complex fluids
         \item Non-equilibrium statistical mechanics
        \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{About the GSP}

\begin{itemize}
  \item Supervisor: Dr. Edoardo Di Napoli
  \item Co-Supervisor: Dr. Xinzhe Wu
  \item SimLab Quantum Materials
  \item Research:
    \begin{itemize}
    \item Development and maintenance of numerical libraries
    \item Design and implementation of high-performance algorithms
    \item Development of new mathematical and computational models within a methodological framework
    \end{itemize}
    in the scope of computational materials science and quantum materials.
\end{itemize}
\end{frame}

\part{Introduction to HPX}
\makepart

\begin{frame}
\frametitle{Current sitution in high performance computing (HPC)}
Currently, speed-up in computing does not stem from higher CPU frequency, but increased parallelism.
However, we already face the following challenges in HPC:
\begin{itemize}
  \item Ease of programming
  \item Inability to handle dynamically changing workloads
  \item Scalability
  \item Efficient utilization of system resources
\end{itemize}
\(\implies\) a need for a new execution model: ParalleX, which is implemented by HPX
\end{frame}

\begin{frame}
\frametitle{ParalleX}
ParalleX is a new parallel execution model that offers an alternative to the conventional computation models(e.g. message passing):
\begin{itemize}
  \item Split-phase transaction model
  \item Message-driven
  \item Distributed shared memory
  \item Multi-threaded
  \item Futures synchronization
  \item Local Control Objects (LCOs)
  \item ...
\end{itemize}
ParalleX focusses on latency hiding instead of latency avoidance.
\end{frame}

\begin{frame}
\frametitle{About HPX}
\begin{itemize}
  \item High Performance ParalleX (HPX) is the first runtime system implementation of the ParalleX execution model.
  \item Development: STE||AR group \\ Louisiana State University \\ LSU Center for Computation and Technology
  \item Released as open source under the Boost Software License
  \item Current version: HPX V1.3.0, released on 23.05.2019
  \item Aims to be a \textbf{C++ standards conforming implementation} of the Parallelism and Concurrency proposals for C++ 17/20/23/...
  \item This means: HPX is a C++ library that supports \textbf{dynamic adaptive resource management} and \textbf{lightweight task programming and scheduling} within the context of a \textbf{global address space}. 
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{On learning HPX}
\framesubtitle{An opinion of a non-CS/HPC student}
Learning curve on of HPX is quite steep - in the first days quite some dedication, effort and endurance is needed\footnote{\color{fzjblue} \href{https://github.com/STEllAR-GROUP/tutorials/blob/master/hlrs2017/session1/README.md}{Why is the HPX code repo so big and complicated?}}.
\begin{itemize}
  \item Probably the easiest way in the beginning: watch
    \color{fzjblue}\href{https://www.youtube.com/playlist?list=PL1tk5lGm7zvSXfS-sqOOmIJ0lFNjKze18}{this nice playlist}
    \color{black} in 1.25x speed on the youtube channel of
    \color{fzjblue}\href{https://www.youtube.com/user/cscsch}{cscsch}
    \color{black}(Swiss National Supercomputing Centre)
  \item Be aware that the
    \color{fzjblue}\href{https://stellar-group.github.io/hpx/docs/sphinx/latest/html/api.html}{API reference}
    \color{black}is not complete
  \item Be aware that there exist at least 5 different ``Hello, World!'' examples\footnote{Paths are with respect to \color{fzjblue}\url{https://github.com/STEllAR-GROUP/}\color{black}}:
  \begin{itemize}
    \item hpx/examples/hello\_world\_component/*: 3 files; 28, 30 \& 55 lines
    \item hpx/examples/quickstart/hello\_world\_1.cpp; 22 lines
    \item hpx/examples/quickstart/hello\_world\_2.cpp; 24 lines
    \item hpx/examples/quickstart/hello\_world\_distributed.cpp; 156 lines
    \item tutorials/examples/01\_hello\_world/hello\_world.cpp; 71 lines
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{HPX: Tasks and Threads}
\begin{itemize}
 \item HPX: Task-based parallelism
 \item Split up big problem into smaller tasks
 \item Tasks are worked off as HPX (lightweight) Threads by the OS Threads
 \item Task size is crucial: not too small and not too big
 \item Number of tasks can even be as high as \(\mathcal{O}(10^8)\)
\end{itemize}
\vspace{0.3cm}
\begin{center}
\begin{tikzpicture}[
x=1cm,
y=1cm,
tasknode/.style={rectangle, draw=fzjblue!60, fill=fzjblue!5, very thick, minimum height=1cm},
]
\node at (-3cm,2cm) {Tasks too large};
\node[tasknode] at (-5cm  +0cm,0cm) [draw, thick, minimum width=2cm] {\(T_1\)};
\node[tasknode] at (-5cm  +2cm,0cm) [draw, thick, minimum width=2cm] {\(T_3\)};
\node[tasknode] at (-5cm  +4cm,0cm) [draw, thick, minimum width=2cm] {\(T_5\)};
\node[tasknode] at (-5cm+0.1cm,1cm) [draw, thick, minimum width=2.2cm] {\(T_2\)};
\node[tasknode] at (-5cm+2.2cm,1cm) [draw, thick, minimum width=2.2cm] {\(T_4\)};

\node at (3,2) {Right task size};
\node[tasknode] at (+1,0) [draw, thick, minimum width=1cm] {\(T_1\)};
\node[tasknode] at (+2,0) [draw, thick, minimum width=1cm] {\(T_3\)};
\node[tasknode] at (+3.2,1) [draw, thick, minimum width=1cm] {\(T_5\)};
\node[tasknode] at (+1.1,1) [draw, thick, minimum width=1.2cm] {\(T_2\)};
\node[tasknode] at (+2.2,1) [draw, thick, minimum width=1.2cm] {\(T_4\)};

\node[tasknode] at (3.05,0) [draw, thick, minimum width=1.1cm] {\(T_6\)};
\node[tasknode] at (4.1,0) [draw, thick, minimum width=1.1cm] {\(T_7\)};
\node[tasknode] at (5.1,0) [draw, thick, minimum width=1cm] {\(T_8\)};
\node[tasknode] at (4.3,1) [draw, thick, minimum width=1.2cm] {\(T_9\)};
% \node[tasknode] at (+2.1,1) [draw, thick, minimum width=1.05cm] {\(T_{10}\)};
% \node[tasknode] at (+2.1,1) [draw, thick, minimum width=1.05cm] {\(T_{11}\)};
\end{tikzpicture}
\end{center}
\end{frame}

\begin{frame}
\frametitle{Comparison of HPX and OpenMP}
\begin{center}
\begin{tabular}{ |c|c| } 
 \hline
 HPX & OpenMP \\
 \hline
 C++ library & Compiler extension to C and Fortran \\
 Core language: \texttt{hpx::C++} & \texttt{\#pragma omp} directives \\
 Task-based parallelism & Parallel regions (fork-join model) \\
 AGAS (active global address space) & shared memory \\
 \hline
\end{tabular}
\end{center}
\vspace{0.3cm}
\begin{center}
\begin{tikzpicture}[
initnode/.style={circle, draw=fzjgreen!60, fill=fzjgreen!5, very thick, minimum size=5mm},
masternode/.style={rectangle, draw=fzjred!60, fill=fzjred!5, very thick, minimum size=5mm},
slavenode/.style={rectangle, draw=fzjblue!60, fill=fzjblue!5, very thick, minimum size=5mm},
]
\node[initnode]      at (-5, -1) {S};
\node[slavenode]     at (-4,  1) {2};
\node[slavenode]     at (-4,  0) {1};
\node[slavenode]     at (-4, -1) {0};
\node[slavenode]     at (-3,  1) {2};
\node[slavenode]     at (-3,  0) {1};
\node[slavenode]     at (-3, -1) {0};
\node[slavenode]     at (-2,  1) {2};
\node[slavenode]     at (-2,  0) {1};
\node[slavenode]     at (-2, -1) {0};
\node[initnode]      at (-1, -1) {E};
\draw[->] (-5+0.31,  -1) -- (-4-0.27, -1);
\draw[->] (-4.5,  1) -- (-4-0.27,  1);
\draw[->] (-4.5,  0) -- (-4-0.27,  0);
\draw[->] (-4.5, -1) -- (-4-0.27, -1);
\draw[-]  (-4.5, -1) -- (-4.5, 1);
\draw[->] (-4+0.27,  1) -- (-3-0.27,  1);
\draw[->] (-4+0.27,  0) -- (-3-0.27,  0);
\draw[->] (-4+0.27, -1) -- (-3-0.27, -1);
\draw[->] (-3+0.27,  1) -- (-2-0.27,  1);
\draw[->] (-3+0.27,  0) -- (-2-0.27,  0);
\draw[->] (-3+0.27, -1) -- (-2-0.27, -1);
\draw[->] (-2+0.27,  1) -- (-1.5,  1);
\draw[->] (-2+0.27,  0) -- (-1.5,  0);
\draw[-]  (-1.5, -1) -- (-1.5, 1);
\draw[->] (-2+0.27,  -1) -- (-1-0.31, -1);

\node[initnode]      at (1, -1) {S};
\node[masternode]    at (2, -1) {0};
\node[masternode]    at (3, -1) {0};
\node[slavenode]     at (3, -0) {1};
\node[slavenode]     at (3,  1) {2};
\node[masternode]    at (4, -1) {0};
\node[initnode]      at (5, -1) {E};
\draw[->] (1+0.31, -1) -- (2-0.27, -1);
\draw[->] (2+0.27, -1) -- (3-0.27, -1);
\draw[->] (2.5,  0) -- (3-0.27,  0);
\draw[->] (2.5,  1) -- (3-0.27,  1);
\draw[-]  (2.5, -1) -- (2.5, 1);
\draw[->] (3+0.27, -1) -- (4-0.27, -1);
\draw[->] (3+0.27,  0) -- (3.5,  0);
\draw[->] (3+0.27,  1) -- (3.5,  1);
\draw[-]  (3.5, -1) -- (3.5, 1);
\draw[->] (4+0.27, -1) -- (5-0.31, -1);
\end{tikzpicture}
\end{center}
\end{frame}

\begin{frame}
\frametitle{Comparison of HPX and MPI}
\begin{center}
\begin{tabular}{ |c|c| } 
 \hline
 HPX & MPI \\
 \hline
 C++ library & Interface specification for C and Fortran \\
 Core language: \texttt{hpx::C++} & Core language: MPI\_C, MPI\_F08 \\
 Task-based parallelism & Single program, multiple data (SPMD) \\
 AGAS (active global address space) & Explicit message passing \\
 \hline
\end{tabular}
\end{center}
\vspace{0.3cm}
\begin{center}
\begin{tikzpicture}[
initnode/.style={circle, draw=fzjgreen!60, fill=fzjgreen!5, very thick, minimum size=5mm},
masternode/.style={rectangle, draw=fzjred!60, fill=fzjred!5, very thick, minimum size=5mm},
slavenode/.style={rectangle, draw=fzjblue!60, fill=fzjblue!5, very thick, minimum size=5mm},
]
\node[initnode]      at (-5, -1) {S};
\node[slavenode]     at (-4,  1) {2};
\node[slavenode]     at (-4,  0) {1};
\node[slavenode]     at (-4, -1) {0};
\node[slavenode]     at (-3,  1) {2};
\node[slavenode]     at (-3,  0) {1};
\node[slavenode]     at (-3, -1) {0};
\node[slavenode]     at (-2,  1) {2};
\node[slavenode]     at (-2,  0) {1};
\node[slavenode]     at (-2, -1) {0};
\node[initnode]      at (-1, -1) {E};
\draw[->] (-5+0.31,  -1) -- (-4-0.27, -1);
\draw[->] (-4.5,  1) -- (-4-0.27,  1);
\draw[->] (-4.5,  0) -- (-4-0.27,  0);
\draw[->] (-4.5, -1) -- (-4-0.27, -1);
\draw[-]  (-4.5, -1) -- (-4.5, 1);
\draw[->] (-4+0.27,  1) -- (-3-0.27,  1);
\draw[->] (-4+0.27,  0) -- (-3-0.27,  0);
\draw[->] (-4+0.27, -1) -- (-3-0.27, -1);
\draw[->] (-3+0.27,  1) -- (-2-0.27,  1);
\draw[->] (-3+0.27,  0) -- (-2-0.27,  0);
\draw[->] (-3+0.27, -1) -- (-2-0.27, -1);
\draw[->] (-2+0.27,  1) -- (-1.5,  1);
\draw[->] (-2+0.27,  0) -- (-1.5,  0);
\draw[-]  (-1.5, -1) -- (-1.5, 1);
\draw[->] (-2+0.27,  -1) -- (-1-0.31, -1);

\node[initnode]      at (1, -1) {S};
\node[slavenode]     at (2,  1) {2};
\node[slavenode]     at (2,  0) {1};
\node[slavenode]     at (2, -1) {0};
\node[slavenode]     at (3,  1) {2};
\node[slavenode]     at (3,  0) {1};
\node[slavenode]     at (3, -1) {0};
\node[slavenode]     at (4,  1) {2};
\node[slavenode]     at (4,  0) {1};
\node[slavenode]     at (4, -1) {0};
\node[initnode]      at (5, -1) {E};
\draw[->] (1+0.31,  -1) -- (2-0.27, -1);
\draw[->] (1.5,  1) -- (2-0.27,  1);
\draw[->] (1.5,  0) -- (2-0.27,  0);
\draw[->] (1.5, -1) -- (2-0.27, -1);
\draw[-]  (1.5, -1) -- (1.5, 1);
\draw[->] (2+0.27,  1) -- (3-0.27,  1);
\draw[->] (2+0.27,  0) -- (3-0.27,  0);
\draw[->] (2+0.27, -1) -- (3-0.27, -1);
\draw[dashed] (2+0.27,  1) -- (3-0.27,  1);
\draw[dashed] (2+0.27,  1) -- (3-0.27,  0);
\draw[dashed] (2+0.27,  1) -- (3-0.27, -1);
\draw[dashed] (2+0.27,  0) -- (3-0.27,  1);
\draw[dashed] (2+0.27,  0) -- (3-0.27,  0);
\draw[dashed] (2+0.27,  0) -- (3-0.27, -1);
\draw[dashed] (2+0.27, -1) -- (3-0.27,  1);
\draw[dashed] (2+0.27, -1) -- (3-0.27,  0);
\draw[dashed] (2+0.27, -1) -- (3-0.27, -1);
\draw[->] (3+0.27,  1) -- (4-0.27,  1);
\draw[->] (3+0.27,  0) -- (4-0.27,  0);
\draw[->] (3+0.27, -1) -- (4-0.27, -1);
\draw[dashed] (3+0.27,  1) -- (4-0.27,  1);
\draw[dashed] (3+0.27,  1) -- (4-0.27,  0);
\draw[dashed] (3+0.27,  1) -- (4-0.27, -1);
\draw[dashed] (3+0.27,  0) -- (4-0.27,  1);
\draw[dashed] (3+0.27,  0) -- (4-0.27,  0);
\draw[dashed] (3+0.27,  0) -- (4-0.27, -1);
\draw[dashed] (3+0.27, -1) -- (4-0.27,  1);
\draw[dashed] (3+0.27, -1) -- (4-0.27,  0);
\draw[dashed] (3+0.27, -1) -- (4-0.27, -1);
\draw[->] (4+0.27,  1) -- (4.5,  1);
\draw[->] (4+0.27,  0) -- (4.5,  0);
\draw[-]  (4.5, -1) -- (4.5, 1);
\draw[->] (4+0.27,  -1) -- (5-0.31, -1);
\end{tikzpicture}
\end{center}
\end{frame}

\begin{frame}
\frametitle{The HPX API}
\framesubtitle{Selection: Classes}
\begin{center}
\begin{tabular}{ |l|l| } 
 \hline
 Class & Description \\
 \hline
 \texttt{hpx::thread} & Low level thread of control \\
 \texttt{hpx::mutex} & Low level synchronization facility \\
 \texttt{hpx::lcos::local::condition\_variable} & Signal a condition \\
 \texttt{hpx::future, hpx::shared\_future} & Asynchronous result transport (receiving end) \\
 \texttt{hpx::promise, hpx::lcos::local::promise} & Asynchronous result transport (producing end) \\
 \texttt{hpx::lcos::packaged\_task} & Asynchronous result transport (producing end) \\
 \texttt{hpx::function} & Type erased function object \\
 \texttt{hpx::tuple} & Tuple \\
 \texttt{...} &  \\
 \hline
\end{tabular}
\end{center}
\end{frame}

\begin{frame}
\frametitle{The HPX API}
\framesubtitle{Selection: Functions}
\begin{center}
\begin{tabular}{ |l|l| }
 \hline
 Functions & Description \\
 \hline
 \texttt{hpx::async} & Spawning tasks (returns a future) \\
 \texttt{hpx::make\_ready\_future} & Spawning tasks (returns a ready future) \\
 \texttt{hpx::bind} & Binding Parameters to callables \\
 \texttt{hpx::apply} & Signal a condition \\
 \texttt{future::\{is\_ready, valid, has\_exception\}} & Query state of future \\
 \texttt{future::get} & Return computed result of future \\
 \texttt{future::then} & Continuations of futures \\
 \texttt{hpx::when\_all, hpx::when\_any, hpx::when\_n} & Waiting on one or more futures (non blocking) \\
 \texttt{hpx::wait\_all, hpx::wait\_any, hpx::wait\_n} & Waiting on one or more futures (blocking) \\
 \texttt{hpx::dataflow} & Shortcut to hpx::when\_all(...).then(...) \\
 \texttt{...} &  \\
 \hline
\end{tabular}
\end{center}
\end{frame}


\begin{frame}[fragile]
\frametitle{HPX: Example Program}
\begin{lstlisting}[language=C++]
double calc_area(hpx::future<double> future_r, hpx::future<double> future_pi)
{
    double r = future_r.get(); // r is returned immediately (make_ready_future)
    double pi = future_pi.get(); // pi is returned once the async computation finishes
    return r * r * pi;
}

int hpx_main(variables_map& vm) // In hpx_main the HPX environment is loaded
{
    hpx::future<double> future_r = hpx::make_ready_future(vm["r"].as<double>());
    hpx::future<double> future_pi = hpx::async([](){ return 4.0 * atan(1.0); });
    hpx::future<double> future_area = hpx::dataflow(&calc_area, future_r, future_pi);
    return hpx::finalize(); // Area can be obtained by: future_area.get()
}

int main(int argc, char * argv[]) // Start program by: ./area --r=...
{
    options_description.add_options()("r", value<double>()->default_value(1.0), "Radius: r");
    return hpx::init(options_description, argc, argv); // hpx::init calls hpx_main
}
\end{lstlisting}
\end{frame}

\part{Introduction to Numerical Linear Algebra and Applications}
\makepart

\begin{frame}
\frametitle{Introduction: Numerical Linear Algebra}
Numerical linear algebra is a subfield of numerical analysis and linear algebra,
and it plays an integral role in computational problem solving.
There exist many several algorithms for common problems, a few well-known are:
\begin{itemize}
 \item Solving systems of linear equations
 \item Eigenvalue problem
 \item Matrix inversion problem
 \item Least-squares problem
\end{itemize}
which may be using one of the following matrix operations/decompositions:
\begin{itemize}
 \item Matrix multiplications
 \item LU decomposition
 \item QR decomposition
 \item Spectral decomposition
 \item Singular value decomposition
\end{itemize}
\end{frame}

\part{GEMM}
\makepart

\begin{frame}
\frametitle{GEMM}
\framesubtitle{Applications of Numerical Linear Algebra}
GEMM - GEneral Matrix Multiply
\begin{itemize}
 \item Basic binary operation in Linear Algebra, which has numerous applications in mathematics, science and engineering.
 \item More fundamental applications of matrix multiplications include
  \begin{enumerate}
   \item Systems of Linear Algebraic Equations (SLAE) can be expressed as a single matrix equation, e.g. \(Ax = y\). 
   \item Linear map between two vector spaces \(U\) and \(V\) over the same field \(F\).
  \end{enumerate}
 \item Motivation: A large amount (>70\%) of runtime in ChASE (\emph{(ED Napoli, 2019)}) routine is used for GEMM.
 \item Let the field \(F\) be \(\mathbb{R}\) or \(\mathbb{C}\), \(A =\big( a_{ij} \big) \in F^{m \times n}, B =\big( b_{jk} \big) \in F^{n \times p}\). Then,
 \begin{equation}
  C=\big( c_{ik} \big)=AB \in F^{m \times p},
 \end{equation}
 \begin{equation}
  c_{ik} = \sum_{j=1}^n{a_{ij}b_{jk}}
 \end{equation}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{GEMM of Blocked Matrices}
\framesubtitle{Applications of Numerical Linear Algebra}
\(\implies\) most simple implementation consists of 3 nested for-loops: \\
\vspace{0.005cm}\texttt{for 0 <= i < m, 0 <= j < n, 0 <= k < p, do: C[i][k] += A[i][j] * B[j][k]}\\
\vspace{0.25cm}Better approach: Discretize matrices into blocks, perform GEMM \textbf{block-wise}\\
\vspace{0.005cm}Let the field \(F\) again be \(\mathbb{R}\) or \(\mathbb{C}\),
\(A =\big( A_{ij} \big) \in F^{M \times N \times m \times n}\),
\(B =\big( B_{jk} \big) \in F^{N \times P \times n \times p}\).\\
\vspace{0.005cm}Then:
\begin{equation}
 C=\big( C_{ik} \big)=AB \in F^{M \times P \times m \times p},
\end{equation}
\begin{equation}
 C_{ik} = \big( c_{ik,i'k'} \big) = \sum_{j=1}^n{A_{ij}B_{jk}},
\end{equation}
\begin{equation}
 c_{ik,i'k'} = \sum_{j=1}^N{\sum_{j'=1}^n{a_{ij,i'j'}b_{jk,j'k'}},}
\end{equation}
\end{frame}

\begin{frame}
\frametitle{GEMM of Blocked Matrices}
\frametitle{A Small Example}
Let \(M = N = P = m = n = p = 2\):
\vspace{0.3cm}
\begin{center}
\begin{tikzpicture}[
matrixnode/.style={rectangle, draw=fzjgreen!60, fill=fzjgreen!5, very thick, minimum width=2cm, minimum height=2cm},
blocknode/.style={rectangle, draw=fzjred!60, fill=fzjred!5, very thick, minimum width=1cm, minimum height=1cm},
]
  \node[matrixnode] at (-2,0) {\(A\)};
  \node at (-0.5,0) {\(\cdot\)};
  \node[matrixnode] at (1,0) {\(B\)};
  \node at (3,0) {\(=\)};
  \node[matrixnode] at (5,0) {\(C\)};
         
  \foreach \i in {0,...,1}
    \foreach \j in {0,...,1} 
       \node[blocknode] at (\i -2-0.5,-\j-2) {\(A_{\text{\i\j}}\)};
  \node at (-0.5,-2.5) {\(\cdot\)};     
  \foreach \j in {0,...,1}
    \foreach \k in {0,...,1} 
       \node[blocknode] at (\j +1-0.5,-\k-2) {\(B_{\text{\j\k}}\)};
  \node at (3,-2.5) {\(=\)};     
  \foreach \i in {0,...,1}
    \foreach \k in {0,...,1} 
       \node[blocknode] at (\i +5-0.5,-\k-2) {\(C_{\text{\i\k}}\)};
\end{tikzpicture}
\end{center}
\end{frame}

\begin{frame}
\frametitle{GEMM of Blocked Matrices}
\frametitle{A Small Example}
Let \(m = n = p = M = N = P = 2\):
\vspace{0.3cm}
\begin{center}
\begin{tikzpicture}[
blocknode/.style={rectangle, draw=fzjred!60, fill=fzjred!5, very thick, minimum width=2cm, minimum height=2cm},
elemnode/.style={rectangle, draw=fzjblue!60, fill=fzjblue!5, very thick, minimum width=1cm, minimum height=1cm},
]
  \node[blocknode] at (-2,0) {\(A_{ij}\)};
  \node at (-0.5,0) {\(\cdot\)};
  \node[blocknode] at (1,0) {\(B_{jk}\)};
  \node at (3,0) {\(=\)};
  \node[blocknode] at (5,0) {\(A_{ij}B_{jk}\)};
         
  \foreach \i in {0,...,1}
    \foreach \j in {0,...,1} 
       \node[elemnode] at (\i -2-0.5,-\j-2) {\(a_{ij,\text{\i\j}}\)};
  \node at (-0.5,-2.5) {\(\cdot\)};     
  \foreach \j in {0,...,1}
    \foreach \k in {0,...,1} 
       \node[elemnode] at (\j +1-0.5,-\k-2) {\(b_{jk,\text{\j\k}}\)};
  \node at (3,-2.5) {\(=\)};     
  \foreach \i in {0,...,1}
    \foreach \k in {0,...,1} 
       \node[elemnode] at (\i +5-0.5,-\k-2) {\(...\)};
\end{tikzpicture}
\end{center}
\end{frame}

\part{QR}
\makepart

\begin{frame}
\frametitle{QR decomposition}
\framesubtitle{Applications of Numerical Linear Algebra}
QR decomposition
\begin{itemize}
 \item Matrix decomposition of square or rectangular matrices (we only consider square matrices).
 \item Let the field \(F\) be \(\mathbb{R}\) or \(\mathbb{C}\), \(A =\big( a_{ij} \big) \in F^{m \times m}\). Then,
 \begin{equation}
  A = QR,
 \end{equation}
 where \(Q\) is a orthogonal(\(F=\mathbb{R}\)) / unitary(\(F=\mathbb{C}\)) matrix, and \(R\) is an upper triangular matrix.
 \item Computing the QR decomposition:
 \begin{itemize}
  \item Gram-Schmidt orthogonalisation process
  \item \textbf{Householder reflection}
  \item Givens rotations
 \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Applications of QR decomposition}
\framesubtitle{Examples}
\begin{itemize}
 \item Computing Eigenvalues (QR algorithm)
 \item Computing orthogonal base 
 \item Solving least-squares problem
 \item Solution to linear inverse problems
\end{itemize}
A selection of papers in my research ares which use QR decomposition:
\begin{itemize}
 \item An evaluation of noise reduction algorithms for particle-based fluid simulations in multi-scale applications (M.J. Zimon et al., 2016)
 \item Dynamic mode decomposition of numerical and experimental data (P.J. Schmid, 2010)
 \item Krylov Methods for the Incompressible Navier-Stokes Equations (W.S. Edwards, 1994)
 \item Computing Lyapunov exponents of continuous dynamical systems: method of Lyapunov vectors (J Lu, 2005)
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{QR decomposition}
\framesubtitle{Algorithm}
\begin{center}
\begin{tikzpicture}[
nodea/.style={rectangle, draw=fzjblue, very thick, minimum width=0.3cm, minimum height=0.3cm},
nodeb/.style={rectangle, draw=fzjred, fill=fzjblue, very thick, minimum width=0.3cm, minimum height=0.3cm},
nodec/.style={rectangle, draw=fzjred, fill=white, very thick, minimum width=0.3cm, minimum height=0.3cm},
drawa/.style={-, draw=fzjblue, very thick},
drawb/.style={-, draw=fzjred, very thick},
]
  \draw[->, dashed, very thick] (0.5*2 - 1.875*1+0.15,-0.5*1-1.875*0) -- (0.5*0 + 1.875*0-0.15,-0.5*1-1.875*0);
  \foreach \jj in {1,...,2}
    \draw[->, very thick] (0.5*2 - 1.875*1+0.15,-0.5*1-1.875*\jj) -- (0.5*0 + 1.875*0-0.15,-0.5*1-1.875*\jj);
  \foreach \jj in {0,...,2}
    \draw[->, very thick] (0.5*2 + 1.875*0+0.15,-0.5*1-1.875*\jj) -- (0.5*0 + 1.875*1-0.15,-0.5*1-1.875*\jj);
  \foreach \jj in {0,...,2}
    \draw[->, very thick] (0.5*2 + 1.875*1+0.15,-0.5*1-1.875*\jj) -- (0.5*0 + 1.875*2-0.15,-0.5*1-1.875*\jj);
  \foreach \jj in {0,...,1}
    \draw[->, very thick] (0.5*2 + 1.875*2+0.15,-0.5*1-1.875*\jj) -- (0.5*0 + 1.875*3-0.15,-0.5*1-1.875*\jj);
  \draw[->, dashed, very thick] (0.5*2 + 1.875*2+0.15,-0.5*1-1.875*2) -- (0.5*0 + 1.875*3-0.15,-0.5*1-1.875*2);
  
  \draw[very thick] (0.5*0 + 1.875*3-0.15,-1.4375) -- (0.5*0 + 1.875*3-0.15,-0.5*1);
  \draw[very thick] (0.5*2 - 1.875*1+0.15,-1.4375) -- (0.5*0 + 1.875*3-0.15,-1.4375);
  \draw[very thick] (0.5*2 - 1.875*1+0.15,-1.4375) -- (0.5*2 - 1.875*1+0.15,-0.5*1-1.875*1);
  
  \draw[very thick] (0.5*0 + 1.875*3-0.15,-0.5*1-1.875*1) -- (0.5*0 + 1.875*3-0.15,-3.3175);
  \draw[very thick] (0.5*2 - 1.875*1+0.15,-3.3175) -- (0.5*0 + 1.875*3-0.15,-3.3175);
  \draw[very thick] (0.5*2 - 1.875*1+0.15,-3.3175) -- (0.5*2 - 1.875*1+0.15,-0.5*1-1.875*2);
  
  \foreach \jj in {0,...,2}
  \foreach \ii in {0,...,2}
  \foreach \j in {0,...,2} 
  \foreach \i in {0,...,2}
     \node[nodea] at (0.5*\i + 1.875*\ii,-0.5*\j-1.875*\jj) {};
       
  \node[nodeb] at (0,0) {};
  \node[nodeb] at (0.5*1 + 1.875*1,0) {};
  \node[nodeb] at (0.5*2 + 1.875*2,0) {};
  
  \node[nodeb] at (0.5*0 + 1.875*0,-0.5*1-1.875*1) {};
  \node[nodeb] at (0.5*1 + 1.875*1,-0.5*1-1.875*1) {};
  \node[nodeb] at (0.5*1 + 1.875*1,-0.5*0-1.875*1) {};
  \node[nodec] at (0.5*0 + 1.875*1,-0.5*1-1.875*1) {};
  \node[nodeb] at (0.5*2 + 1.875*2,-0.5*1-1.875*1) {};
  \node[nodeb] at (0.5*2 + 1.875*2,-0.5*0-1.875*1) {};
  \node[nodec] at (0.5*0 + 1.875*2,-0.5*1-1.875*1) {};
  
  \node[nodeb] at (0.5*0 + 1.875*0,-0.5*2-1.875*2) {};
  \node[nodeb] at (0.5*1 + 1.875*1,-0.5*2-1.875*2) {};
  \node[nodeb] at (0.5*1 + 1.875*1,-0.5*0-1.875*2) {};
  \node[nodec] at (0.5*0 + 1.875*1,-0.5*2-1.875*2) {};
  \node[nodeb] at (0.5*2 + 1.875*2,-0.5*2-1.875*2) {};
  \node[nodeb] at (0.5*2 + 1.875*2,-0.5*0-1.875*2) {};
  \node[nodec] at (0.5*0 + 1.875*2,-0.5*2-1.875*2) {};
  
  \draw[drawb] (0.5*0 + 1.875*1-0.15,-0.5*0-1.875*0+0.15) -- (0.5*0 + 1.875*1+0.15,-0.5*0-1.875*0-0.15);
  \draw[drawb] (0.5*0 + 1.875*1-0.15,-0.5*0-1.875*0-0.15) -- (0.5*0 + 1.875*1+0.171,-0.5*0-1.875*0-0.15);
  \draw[drawb] (0.5*0 + 1.875*1-0.15,-0.5*0-1.875*0+0.171) -- (0.5*0 + 1.875*1-0.15,-0.5*0-1.875*0-0.171);
  
  \draw[drawb] (0.5*0 + 1.875*2-0.15,-0.5*0-1.875*0+0.15) -- (0.5*0 + 1.875*2+0.15,-0.5*0-1.875*0-0.15);
  \draw[drawb] (0.5*0 + 1.875*2-0.15,-0.5*0-1.875*0-0.15) -- (0.5*0 + 1.875*2+0.171,-0.5*0-1.875*0-0.15);
  \draw[drawb] (0.5*0 + 1.875*2-0.15,-0.5*0-1.875*0+0.171) -- (0.5*0 + 1.875*2-0.15,-0.5*0-1.875*0-0.171);
  
  \node (v1) at (0.5*0 + 1.875*0-0.16,-0.5*0-1.875*1+0.15) {};
  \node (v2) at (0.5*0 + 1.875*0+0.15,-0.5*0-1.875*1-0.1275) {};
  \node (v3) at (0.5*0 + 1.875*0+0.15,-0.5*0-1.875*1+0.15) {};
  \draw[drawb] (0.5*0 + 1.875*0-0.171,-0.5*0-1.875*1+0.15) -- (0.5*0 + 1.875*0+0.171,-0.5*0-1.875*1+0.15);
  \draw[draw=fzjred, fill=fzjblue, very thick, minimum width=0.3cm, minimum height=0.3cm] (v1.center)--(v2.center)--(v3.center)--(v1.center);
  \draw[drawa] (0.5*0 + 1.875*1-0.15,-0.5*0-1.875*1+0.15) -- (0.5*0 + 1.875*1+0.15,-0.5*0-1.875*1-0.15);
  \draw[drawa] (0.5*0 + 1.875*2-0.15,-0.5*0-1.875*1+0.15) -- (0.5*0 + 1.875*2+0.15,-0.5*0-1.875*1-0.15);

  \node (v1) at (0.5*0 + 1.875*0-0.16,-0.5*0-1.875*2+0.15) {};
  \node (v2) at (0.5*0 + 1.875*0+0.15,-0.5*0-1.875*2-0.1275) {};
  \node (v3) at (0.5*0 + 1.875*0+0.15,-0.5*0-1.875*2+0.15) {};
  \draw[drawb] (0.5*0 + 1.875*0-0.171,-0.5*0-1.875*2+0.15) -- (0.5*0 + 1.875*0+0.171,-0.5*0-1.875*2+0.15);
  \draw[draw=fzjred, fill=fzjblue, very thick, minimum width=0.3cm, minimum height=0.3cm] (v1.center)--(v2.center)--(v3.center)--(v1.center);
  \draw[drawa] (0.5*0 + 1.875*1-0.15,-0.5*0-1.875*2+0.15) -- (0.5*0 + 1.875*1+0.15,-0.5*0-1.875*2-0.15);
  \draw[drawa] (0.5*0 + 1.875*2-0.15,-0.5*0-1.875*2+0.15) -- (0.5*0 + 1.875*2+0.15,-0.5*0-1.875*2-0.15);
\end{tikzpicture}
\end{center}
\end{frame}

\part{Benchmark: Results}
\makepart

% \begin{frame}
% \frametitle{GEMM Shared Memory}
% \begin{center}
% \begin{tikzpicture}
%     \begin{axis}[xlabel={Threads}, ylabel={Runtime[ms]}]
%         \addplot[color=black,mark=x]
%             coordinates
%             {
%                 (2,-2.8559703) (3,-3.5301677) (4,-4.3050655) (5,-5.1413136) (6,-6.0322865) (7,-6.9675052) (8,-7.9377747)
%             };
%             \addlegendentry{Serial Naive}
%         \addplot[color=fzjblue,mark=x]
%             coordinates
%             {
%                 (2,-3.8559703) (3,-4.5301677) (4,-5.3050655) (5,-6.1413136) (6,-7.0322865) (7,-8.9675052) (8,-8.9377747)
%             };
%             \addlegendentry{Serial Tiled}
%         \addplot[color=fzjorange,mark=x]
%             coordinates
%             {
%                 (2,-3.8559703) (3,-4.5301677) (4,-5.3050655) (5,-6.1413136) (6,-7.0322865) (7,-8.9675052) (8,-8.9377747)
%             };
%             \addlegendentry{OMP Row}
%         \addplot[color=fzjviolet,mark=x]
%             coordinates
%             {
%                 (2,-3.8559703) (3,-4.5301677) (4,-5.3050655) (5,-6.1413136) (6,-7.0322865) (7,-8.9675052) (8,-8.9377747)
%             };
%             \addlegendentry{OMP Cell}
%         \addplot[color=fzjgreen,mark=x]
%             coordinates
%             {
%                 (2,-3.8559703) (3,-4.5301677) (4,-5.3050655) (5,-6.1413136) (6,-7.0322865) (7,-8.9675052) (8,-8.9377747)
%             };
%             \addlegendentry{HPX v1}
%         \addplot[color=fzjred,mark=x]
%             coordinates
%             {
%                 (2,-3.8559703) (3,-4.5301677) (4,-5.3050655) (5,-6.1413136) (6,-7.0322865) (7,-8.9675052) (8,-8.9377747)
%             };
%             \addlegendentry{HPX v2}
%         \addplot[color=fzjlightblue,mark=x]
%             coordinates
%             {
%                 (2,-3.8559703) (3,-4.5301677) (4,-5.3050655) (5,-6.1413136) (6,-7.0322865) (7,-8.9675052) (8,-8.9377747)
%             };
%             \addlegendentry{HPX v312}
%     \end{axis}
% \end{tikzpicture}
% \end{center}
% \end{frame}

\begin{frame}
\frametitle{GEMM Shared Memory}
Let \(m = n = p = 4000, M = N = P = 40\), vary number of threads:
\begin{center}
\begin{tikzpicture}
\begin{axis}[name=plot1,height=6.0cm,width=6.0cm,xlabel={Threads \(T\)},ylabel={Runtime [s]},legend style={font=\scriptsize}]
        \addplot[color=black,mark=x]
            coordinates
            {
                (1,42.500)
            };
            \addlegendentry{$0.25$ Serial Naive}
        \addplot[color=fzjblue,mark=x]
            coordinates
            {
                (1,31.806)
            };
            \addlegendentry{Serial Tiled}
        \addplot[color=fzjorange,mark=x]
            coordinates
            {
                (2,16.407) (4,9.053) (5,7.355) (8,4.665) (10,3.761) (20,1.979)
            };
            \addlegendentry{OMP Row Tiled}
        \addplot[color=fzjviolet,mark=x]
            coordinates
            {
                (4,9.049) (16,3.313) (25,2.170)
            };
            \addlegendentry{OMP Cell Tiled}
\end{axis}
\begin{axis}[name=plot2,at={($(plot1.east)+(1.7cm,0)$)},anchor=west,height=6.0cm,width=6.0cm,xlabel={Threads \(T\)},ylabel={Runtime [s]},legend style={font=\scriptsize}]
        \addplot[color=fzjorange,mark=x]
            coordinates
            {
                (2,16.407) (4,9.053) (5,7.355) (8,4.665) (10,3.761) (20,1.979)
            };
            \addlegendentry{OMP Row Tiled}
        \addplot[color=fzjgreen,mark=x]
            coordinates
            {
                (2,16.427) (4,10.473) (5,7.386) (8,5.419) (10,3.831) (20,2.048)
            };
            \addlegendentry{HPX \(\text{foreach}_{0 \leq i' < M}\)}
        \addplot[color=fzjred,mark=x]
            coordinates
            {
                (2,16.035) (4,8.848) (5,7.142) (8,4.501) (10,3.615) (20,1.882)
            };
            \addlegendentry{HPX future \(C_{ik}\)}
        \addplot[color=fzjlightblue,mark=x]
            coordinates
            {
                (2,16.387) (4,9.015) (5,7.254) (8,4.599) (10,3.679) (20,1.941)
            };
            \addlegendentry{HPX future \(A_{ij}B_{jk}\)}
\end{axis}
\end{tikzpicture}
\end{center}
\end{frame}

\begin{frame}
\frametitle{GEMM Shared Memory}
Let \(m = n = p = 4000, M = N = P = 40\), vary number of threads:
\begin{center}
\begin{tikzpicture}
\begin{axis}[name=plot1,height=6.5cm,width=13cm,xlabel={Threads \(T\)},ylabel={Runtimes Ratio [1]},legend style={font=\scriptsize}]
        \addplot[color=fzjorange,mark=x]
            coordinates
            {
                (2,16.407/16.407) (4,9.053/9.053) (5,7.355/7.355) (8,4.665/4.665) (10,3.761/3.761) (20,1.979/1.979)
            };
            \addlegendentry{OMP Row Tiled}
        \addplot[color=fzjgreen,mark=x]
            coordinates
            {
                (2,16.427/16.407) (4,10.473/9.053) (5,7.386/7.355) (8,5.419/4.665) (10,3.831/3.761) (20,2.048/1.979)
            };
            \addlegendentry{HPX \(\text{foreach}_{0 \leq i' < M}\)}
        \addplot[color=fzjred,mark=x]
            coordinates
            {
                (2,16.035/16.407) (4,8.848/9.053) (5,7.142/7.355) (8,4.501/4.665) (10,3.615/3.761) (20,1.882/1.979)
            };
            \addlegendentry{HPX future \(C_{ik}\)}
        \addplot[color=fzjlightblue,mark=x]
            coordinates
            {
                (2,16.387/16.407) (4,9.015/9.053) (5,7.254/7.355) (8,4.599/4.665) (10,3.679/3.761) (20,1.941/1.979)
            };
            \addlegendentry{HPX future \(A_{ij}B_{jk}\)}
\end{axis}
\end{tikzpicture}
\end{center}
\(\implies\) HPX can be faster than OpenMP, even for embarrassingly parallel problems. 
\end{frame}

\begin{frame}
\frametitle{GEMM Shared Memory}
Vary number of threads \(T\), and let \(m = n = p = 400\sqrt{T}, M = N = P = \sqrt{T}\):
\begin{center}
\begin{tikzpicture}
\begin{axis}[name=plot1,height=6.0cm,width=13.0cm,ymode=log,xlabel={Threads \(T\)},xmin=0,xmax=50,ylabel={Runtime [ms]},legend style={font=\tiny}]
        \addplot[color=fzjblue,mark=*]
            coordinates
            {
                (1,39)
            };
            \addlegendentry{Serial Tiled}
        \addplot[color=fzjorange,mark=+]
            coordinates
            {
                (1,40) (4,9) (16,29) (25,41) (36,54)
            };
            \addlegendentry{OMP Row Tiled}
        \addplot[color=fzjviolet,mark=+]
            coordinates
            {
                (1,41) (4,136) (16,274) (25,381) (36,530)
            };
            \addlegendentry{OMP Cell Tiled}
        \addplot[color=fzjgreen,mark=x]
            coordinates
            {
                (1,46) (4,167) (16,650) (25,1051) (36,3546)
            };
            \addlegendentry{HPX \(\text{foreach}_{0 \leq i' < M}\)}
        \addplot[color=fzjred,mark=x]
            coordinates
            {
                (1,38) (4,88) (16,337) (25,606) (36,1175)
            };
            \addlegendentry{HPX future \(C_{ik}\)}
        \addplot[color=fzjlightblue,mark=x]
            coordinates
            {
                (1,40) (4,126) (16,211) (25,267) (36,739)
            };
            \addlegendentry{HPX future \(A_{ij}B_{jk}\)}    
        \addplot[color=fzjblue!50!fzjorange,mark=o]
            coordinates
            {
                (1,41) (4,52)
            };
            \addlegendentry{MPI v1}
        \addplot[color=fzjblue!50!fzjgreen,mark=o]
            coordinates
            {
                (1,39) (4,91)
            };
            \addlegendentry{MPI v2}
        \addplot[color=fzjlightblue!50!fzjviolet,mark=asterisk]
            coordinates
            {
                (1,73) (4,405)
            };
            \addlegendentry{HPX dist v1}
        \addplot[color=fzjred!50!fzjorange,mark=asterisk]
            coordinates
            {
                (1,43) (4,315)
            };
            \addlegendentry{HPX dist v2}
\end{axis}
\end{tikzpicture}
\end{center}
\end{frame}

\includetitle{Slides/title}

\end{document}
